<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Bracket Overlay</title>
    <style>
        @font-face {
            font-family: 'PixelFont';
            src: url('data:font/truetype;charset=utf-8;base64,') format('truetype');
            /* Fallback to monospace for pixel-perfect rendering */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: transparent;
            color: #00ff00;
            overflow: hidden;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .tournament-bracket {
            width: 100vw;
            height: 100vh;
            padding: 20px;
            position: relative;
        }

        .tournament-header {
            text-align: center;
            margin-bottom: 30px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        .tournament-title {
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
            margin-bottom: 10px;
        }

        .tournament-status {
            font-size: 24px;
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
        }

        .bracket-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: calc(100vh - 200px);
            overflow: hidden;
        }

        .bracket-round {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 100%;
            min-width: 200px;
            position: relative;
        }

        .round-header {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            margin-bottom: 20px;
            position: absolute;
            top: 0;
            width: 100%;
        }

        .bracket-match {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .bracket-match.active {
            border-color: #ffff00;
            box-shadow: 0 0 15px #ffff00;
            animation: pulse 1s ease-in-out infinite alternate;
        }

        .bracket-match.completed {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }

        .bracket-match.pending {
            border-color: #666;
            background: rgba(102, 102, 102, 0.1);
        }

        .match-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            font-size: 16px;
            font-weight: bold;
        }

        .match-player.winner {
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
        }

        .match-player.loser {
            color: #666;
            text-decoration: line-through;
        }

        .player-name {
            flex: 1;
            text-align: left;
        }

        .player-seed {
            font-size: 12px;
            color: #aaa;
            margin-right: 10px;
        }

        .winner-crown {
            color: #ffd700;
            font-size: 18px;
            text-shadow: 0 0 5px #ffd700;
        }

        .match-vs {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin: 5px 0;
        }

        .bracket-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .connecting-line {
            stroke: #00ff00;
            stroke-width: 2;
            opacity: 0.6;
            animation: lineGlow 3s ease-in-out infinite alternate;
        }

        .tournament-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            min-width: 200px;
        }

        .info-label {
            color: #aaa;
        }

        .info-value {
            color: #00ff00;
            font-weight: bold;
        }

        .winner-celebration {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .winner-celebration.show {
            display: block;
            animation: celebrationPulse 2s ease-in-out infinite;
        }

        .winner-text {
            font-size: 36px;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            margin-bottom: 20px;
        }

        .winner-name {
            font-size: 48px;
            color: #ffff00;
            text-shadow: 0 0 15px #ffff00;
            font-weight: bold;
        }

        /* Animations */
        @keyframes glow {
            from { text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00; }
            to { text-shadow: 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00; }
        }

        @keyframes pulse {
            from { box-shadow: 0 0 15px #ffff00; }
            to { box-shadow: 0 0 25px #ffff00, 0 0 35px #ffff00; }
        }

        @keyframes lineGlow {
            from { opacity: 0.4; }
            to { opacity: 0.8; }
        }

        @keyframes celebrationPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .tournament-title { font-size: 36px; }
            .bracket-match { padding: 10px; min-height: 60px; }
            .match-player { font-size: 14px; }
        }

        /* Hide scrollbars */
        ::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body>
    <div class="tournament-bracket">
        <div class="tournament-header">
            <div class="tournament-title" id="tournament-title">TOURNAMENT BRACKET</div>
            <div class="tournament-status" id="tournament-status">LOADING...</div>
        </div>

        <div class="bracket-container" id="bracket-container">
            <!-- Bracket rounds will be dynamically generated here -->
        </div>

        <svg class="bracket-lines" id="bracket-lines">
            <!-- Connecting lines will be drawn here -->
        </svg>

        <div class="tournament-info" id="tournament-info">
            <div class="info-row">
                <span class="info-label">ROUND:</span>
                <span class="info-value" id="current-round">- / -</span>
            </div>
            <div class="info-row">
                <span class="info-label">PLAYERS:</span>
                <span class="info-value" id="player-count">0</span>
            </div>
            <div class="info-row">
                <span class="info-label">MATCHES:</span>
                <span class="info-value" id="match-count">0</span>
            </div>
        </div>

        <div class="winner-celebration" id="winner-celebration">
            <div class="winner-text">WINNER!</div>
            <div class="winner-name" id="winner-name">CHAMPION</div>
        </div>
    </div>

    <script>
        class TournamentBracketOverlay {
            constructor() {
                this.tournamentData = null;
                this.lastUpdateTime = 0;
                this.animationQueue = [];
                this.isAnimating = false;
                
                // Connect to streaming API
                this.connectToAPI();
                
                // Start update loop
                this.startUpdateLoop();
                
                console.log('[TournamentBracketOverlay] Initialized');
            }

            connectToAPI() {
                // WebSocket connection for real-time updates
                this.socket = new WebSocket('ws://localhost:3001/streaming-socket');
                
                this.socket.onopen = () => {
                    console.log('[TournamentBracketOverlay] WebSocket connected');
                    // Subscribe to tournament bracket updates
                    this.socket.send(JSON.stringify({
                        event: 'subscribe',
                        streams: ['tournamentBracket', 'tournament']
                    }));
                };
                
                this.socket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleWebSocketMessage(data);
                };
                
                this.socket.onerror = (error) => {
                    console.error('[TournamentBracketOverlay] WebSocket error:', error);
                    // Fallback to HTTP polling
                    this.startHTTPPolling();
                };
                
                this.socket.onclose = () => {
                    console.log('[TournamentBracketOverlay] WebSocket disconnected');
                    // Try to reconnect after delay
                    setTimeout(() => this.connectToAPI(), 5000);
                };
            }

            startHTTPPolling() {
                setInterval(() => {
                    this.fetchTournamentData();
                }, 2000);
            }

            async fetchTournamentData() {
                try {
                    const response = await fetch('http://localhost:3001/api/tournament/bracket');
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.data) {
                            this.updateTournamentData(data.data);
                        }
                    }
                } catch (error) {
                    console.error('[TournamentBracketOverlay] HTTP fetch error:', error);
                }
            }

            handleWebSocketMessage(data) {
                switch (data.event || data.type) {
                    case 'tournament-update':
                    case 'tournamentBracket-update':
                        if (data.data) {
                            this.updateTournamentData(data.data);
                        }
                        break;
                    case 'initial-data':
                        if (data.data && data.data.tournamentBracket) {
                            this.updateTournamentData(data.data.tournamentBracket);
                        }
                        break;
                }
            }

            updateTournamentData(data) {
                if (!data || JSON.stringify(data) === JSON.stringify(this.tournamentData)) {
                    return; // No change
                }

                const previousData = this.tournamentData;
                this.tournamentData = data;
                
                this.updateUI();
                
                // Check for completed matches to animate
                if (previousData) {
                    this.checkForUpdates(previousData, data);
                }
            }

            updateUI() {
                if (!this.tournamentData) {
                    this.showNoTournament();
                    return;
                }

                this.updateHeader();
                this.renderBracket();
                this.updateInfo();
            }

            updateHeader() {
                const titleEl = document.getElementById('tournament-title');
                const statusEl = document.getElementById('tournament-status');
                
                if (titleEl) {
                    titleEl.textContent = this.tournamentData.name || 'TOURNAMENT BRACKET';
                }
                
                if (statusEl) {
                    const status = this.tournamentData.tournament?.status || 'unknown';
                    statusEl.textContent = `${status.toUpperCase()} - ${this.tournamentData.format?.toUpperCase() || 'UNKNOWN'}`;
                }
            }

            renderBracket() {
                const container = document.getElementById('bracket-container');
                if (!container || !this.tournamentData.bracket) return;

                container.innerHTML = '';
                
                const rounds = this.tournamentData.bracket.rounds || [];
                
                rounds.forEach((round, roundIndex) => {
                    const roundEl = this.createRoundElement(round, roundIndex, rounds.length);
                    container.appendChild(roundEl);
                });
                
                // Draw connecting lines
                setTimeout(() => this.drawConnectingLines(rounds), 100);
            }

            createRoundElement(matches, roundIndex, totalRounds) {
                const roundEl = document.createElement('div');
                roundEl.className = 'bracket-round fade-in';
                
                const headerEl = document.createElement('div');
                headerEl.className = 'round-header';
                headerEl.textContent = this.getRoundName(roundIndex, totalRounds);
                roundEl.appendChild(headerEl);
                
                matches.forEach((match, matchIndex) => {
                    const matchEl = this.createMatchElement(match);
                    matchEl.style.marginTop = roundIndex === 0 ? '50px' : `${50 + matchIndex * 40}px`;
                    roundEl.appendChild(matchEl);
                });
                
                return roundEl;
            }

            createMatchElement(match) {
                const matchEl = document.createElement('div');
                matchEl.className = `bracket-match ${match.status}`;
                matchEl.dataset.matchId = match.matchId;
                
                const player1 = this.getPlayerById(match.players[0]);
                const player2 = this.getPlayerById(match.players[1]);
                
                matchEl.innerHTML = `
                    <div class="match-player ${match.winner === match.players[0] ? 'winner' : match.winner ? 'loser' : ''}">
                        <span class="player-seed">${player1?.seed || '-'}</span>
                        <span class="player-name">${player1?.playerName || 'TBD'}</span>
                        ${match.winner === match.players[0] ? '<span class="winner-crown">👑</span>' : ''}
                    </div>
                    <div class="match-vs">VS</div>
                    <div class="match-player ${match.winner === match.players[1] ? 'winner' : match.winner ? 'loser' : ''}">
                        <span class="player-seed">${player2?.seed || '-'}</span>
                        <span class="player-name">${player2?.playerName || 'TBD'}</span>
                        ${match.winner === match.players[1] ? '<span class="winner-crown">👑</span>' : ''}
                    </div>
                `;
                
                return matchEl;
            }

            drawConnectingLines(rounds) {
                const svg = document.getElementById('bracket-lines');
                if (!svg) return;
                
                svg.innerHTML = '';
                
                // Simple line drawing between rounds
                for (let i = 0; i < rounds.length - 1; i++) {
                    const currentRound = document.querySelectorAll('.bracket-round')[i];
                    const nextRound = document.querySelectorAll('.bracket-round')[i + 1];
                    
                    if (currentRound && nextRound) {
                        const currentMatches = currentRound.querySelectorAll('.bracket-match');
                        const nextMatches = nextRound.querySelectorAll('.bracket-match');
                        
                        // Draw lines connecting matches
                        for (let j = 0; j < nextMatches.length; j++) {
                            const match1 = currentMatches[j * 2];
                            const match2 = currentMatches[j * 2 + 1];
                            const nextMatch = nextMatches[j];
                            
                            if (match1 && match2 && nextMatch) {
                                this.drawLine(match1, match2, nextMatch);
                            }
                        }
                    }
                }
            }

            drawLine(match1, match2, nextMatch) {
                const svg = document.getElementById('bracket-lines');
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                
                const rect1 = match1.getBoundingClientRect();
                const rect2 = match2.getBoundingClientRect();
                const rectNext = nextMatch.getBoundingClientRect();
                
                const containerRect = svg.getBoundingClientRect();
                
                const x1 = rect1.right - containerRect.left;
                const y1 = rect1.top + rect1.height / 2 - containerRect.top;
                const y2 = rect2.top + rect2.height / 2 - containerRect.top;
                const x2 = rectNext.left - containerRect.left;
                const y3 = rectNext.top + rectNext.height / 2 - containerRect.top;
                
                const midX = x1 + (x2 - x1) / 2;
                
                const pathData = `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x1} ${y2} M ${midX} ${(y1 + y2) / 2} L ${x2} ${y3}`;
                
                line.setAttribute('d', pathData);
                line.setAttribute('class', 'connecting-line');
                
                svg.appendChild(line);
            }

            updateInfo() {
                const currentRoundEl = document.getElementById('current-round');
                const playerCountEl = document.getElementById('player-count');
                const matchCountEl = document.getElementById('match-count');
                
                if (currentRoundEl) {
                    currentRoundEl.textContent = `${this.tournamentData.currentRound || 0} / ${this.tournamentData.totalRounds || 0}`;
                }
                
                if (playerCountEl) {
                    playerCountEl.textContent = this.tournamentData.players?.length || 0;
                }
                
                if (matchCountEl) {
                    const totalMatches = this.getTotalMatches();
                    matchCountEl.textContent = totalMatches;
                }
            }

            checkForUpdates(previousData, newData) {
                // Check for newly completed matches
                if (previousData.bracket && newData.bracket) {
                    this.checkForCompletedMatches(previousData.bracket, newData.bracket);
                }
                
                // Check for tournament completion
                if (newData.tournament?.status === 'completed' && previousData.tournament?.status !== 'completed') {
                    this.showWinnerCelebration(newData.tournament.winner);
                }
            }

            checkForCompletedMatches(previousBracket, newBracket) {
                const previousMatches = this.flattenMatches(previousBracket);
                const newMatches = this.flattenMatches(newBracket);
                
                newMatches.forEach(newMatch => {
                    const previousMatch = previousMatches.find(m => m.matchId === newMatch.matchId);
                    if (previousMatch && previousMatch.status !== 'completed' && newMatch.status === 'completed') {
                        this.animateMatchCompletion(newMatch.matchId);
                    }
                });
            }

            animateMatchCompletion(matchId) {
                const matchEl = document.querySelector(`[data-match-id="${matchId}"]`);
                if (matchEl) {
                    matchEl.style.animation = 'pulse 1s ease-in-out 3';
                    setTimeout(() => {
                        matchEl.style.animation = '';
                    }, 3000);
                }
            }

            showWinnerCelebration(winner) {
                if (!winner) return;
                
                const celebrationEl = document.getElementById('winner-celebration');
                const winnerNameEl = document.getElementById('winner-name');
                
                if (celebrationEl && winnerNameEl) {
                    winnerNameEl.textContent = winner.playerName || 'CHAMPION';
                    celebrationEl.classList.add('show');
                    
                    setTimeout(() => {
                        celebrationEl.classList.remove('show');
                    }, 5000);
                }
            }

            showNoTournament() {
                const titleEl = document.getElementById('tournament-title');
                const statusEl = document.getElementById('tournament-status');
                const containerEl = document.getElementById('bracket-container');
                
                if (titleEl) titleEl.textContent = 'NO ACTIVE TOURNAMENT';
                if (statusEl) statusEl.textContent = 'WAITING FOR TOURNAMENT...';
                if (containerEl) containerEl.innerHTML = '<div style="text-align: center; color: #666; font-size: 24px; margin-top: 200px;">No tournament data available</div>';
            }

            // Utility methods
            getPlayerById(playerId) {
                if (!this.tournamentData.players || !playerId) return null;
                return this.tournamentData.players.find(p => p.playerId === playerId);
            }

            getRoundName(roundIndex, totalRounds) {
                const remaining = totalRounds - roundIndex;
                if (remaining === 1) return 'FINAL';
                if (remaining === 2) return 'SEMIFINALS';
                if (remaining === 3) return 'QUARTERFINALS';
                return `ROUND ${roundIndex + 1}`;
            }

            flattenMatches(bracket) {
                const matches = [];
                if (bracket.rounds) {
                    bracket.rounds.forEach(round => {
                        matches.push(...round);
                    });
                }
                return matches;
            }

            getTotalMatches() {
                if (!this.tournamentData.bracket) return 0;
                return this.flattenMatches(this.tournamentData.bracket).length;
            }

            startUpdateLoop() {
                setInterval(() => {
                    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
                        this.fetchTournamentData();
                    }
                }, 5000);
            }
        }

        // Initialize overlay when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TournamentBracketOverlay();
        });
    </script>
</body>
</html>